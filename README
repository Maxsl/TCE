TCE
--------------
TINY COMMUNICATION ENGINE

开发tce是在学习zeroc代码之后产生的想法，原因在于 zeroc的rpc里面有很多我认为是比较累赘的东西，本想将其瘦身，后来发现代码关联太紧，花时间去改造还不如自己实习一套。
我需要的rpc应该是轻量级的、灵活的、易扩展的，与开发技术、网络、平台、通信协议、应用无关。 rpc应提供简易的编程接口，简化网络编程的工作，避免重复造轮子的过程。

Tce实现RPC的内容：
----------------
1. 接口定义 
2. 数据序列化 
3. 通信传输
4. 消息分派 
5. 调用模型 (5种)

1. 多语言支持 
----------------
 1. c++ ( stl/boost/asio) *
 2. actionscript 
 3. java
 4. python (gevent/libev/websocket) *
 5. javascript 
 6. php
 7. object-c
 8. node-js
  
2. 系统平台 
----------------
 1. android
 2. ios
 3. html5 
 4. windows/linux (c++/java supported)
  
3. 网络通信
----------------
 1. socket （tcp）
 2. mq 		(qpid,zeromq,easymq)
 3. websocket  (http)
 

更多.. 
----------------
 $TCE/doc/tce.md
 

#scott  shanghai china
#86-13916624477 qq:24509826 msn: socketref@hotmail.com
#

features
=======
1. idl maping support py,c++,java,actionscript
2. easy rpc 
3. manay calltypes:
    normal-call (twoway) - user initial call and wait until  return ,thread will be blocked .
    oneway-call        - return immediately after initialing call
    timeout-call       - waiting time specified,thread  will be  unbocked if it reach time.
    async-call         - thread nerver be blocked，return value passed into user function at sometime.
    reversed-call      - establishing one connection，endpoints can setup owner service interfaces for another.
                通常互联网应用时，服务器与客户机链接必须由客户机发起，客户机发起者可以rpc方式调用服务器上的servant服务
                reversed-call实现了了在客户机建立的连接上，由服务器发起rpc服务请求到客户机上，同样的客户机提供servant对象
                基于socket流消息到Rpc函数接口级调用的差别


steps:
=======
1. create your idl, to see <tce1.txt>
2. compiling idl
    python tce2py.py
    it will create app.py
3. execute test_s.py , test_c.py
    illustrating how to rpc

requirements:
==============
1.python 2.6 above
2.ply 3.4


enjoy!


revisions:
===============
2012.9.10 21:35  v0.1.0
1. fixed bugs about reverse-call, oneway call ...
2. testing all api,it's okay

docs:
------
1. idl intr
    struct like c
    builtins: byte,char,short,int,long,float,double,string,bool
    containers:  sequence<type>  as array ( std::vector<> in c++)
                dictionayr<type1,type2> as hash (std::map<>  in c++)
    interfaces : include some callable funcitons in service end.


mappings:
-----------
1. actionscript
    python tce2as.py -i tce1.txt -d actionscript 

2. python 
    python tce2as.py -i tce1.txt -o python/app.py

3. c++
	python tce2cpp.py -i tce1.txt -o tce1.h -if 0 
	
4. java 
	python tce2java.py -i tce1.txt -o /Users/socketref/ply/code/java -k test
	




